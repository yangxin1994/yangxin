# encoding: utf-8
require 'encryption'
require 'error_enum'
require 'tool'
class SessionsController < ApplicationController

	before_filter :require_sign_out, :except => [:destroy, :sina_connect, :renren_connect, :qq_connect, :google_connect]

	# method: get
	# descryption: the page where user logins
	def index
		@renren_app_id = OOPSDATA[RailsEnv.get_rails_env]["renren_app_id"]
		@renren_redirect_uri = OOPSDATA[RailsEnv.get_rails_env]["renren_redirect_uri"]

		@sina_app_key = OOPSDATA[RailsEnv.get_rails_env]["sina_app_key"]
		@sina_redirect_uri = OOPSDATA[RailsEnv.get_rails_env]["sina_redirect_uri"]
		
		@qq_app_id = OOPSDATA[RailsEnv.get_rails_env]["qq_app_id"]
		@qq_redirect_uri = OOPSDATA[RailsEnv.get_rails_env]["qq_redirect_uri"]
		
		@google_client_id = OOPSDATA[RailsEnv.get_rails_env]["google_client_id"]
		@google_redirect_uri = OOPSDATA[RailsEnv.get_rails_env]["google_redirect_uri"]

    @qihu_client_id = OOPSDATA[RailsEnv.get_rails_env]["qihu_app_key"]
    @qihu_redirect_uri = OOPSDATA[RailsEnv.get_rails_env]["qihu_redirect_uri"]
    
  end
	#*descryption*: user submits the login form
	#
	#*http* *method*: post
	#
	#*url*: /sessions
	#
	#*params*:
	#* user: the user hash, the keys of which include:
	#  - email
	#  - password
	#
	#*retval*:
	#* true if successfully login
	#* EMAIL_NOT_EXIST
	#* EMAIL_NOT_ACTIVATED
	#* WRONG_PASSWORD
	def create
		login = User.login(params[:user]["email"], params[:user]["password"], @client_ip)
		third_party_info = decrypt_third_party_user_id(params[:third_party_info])
		case login
		when ErrorEnum::EMAIL_NOT_EXIST
			flash[:error] = "帐号不存在!"
			respond_to do |format|
				format.html	{ redirect_to sessions_path and return }
				format.json	{ render :json => ErrorEnum::EMAIL_NOT_EXIST and return }
			end
		when ErrorEnum::EMAIL_NOT_ACTIVATED
			flash[:error] = "您的帐号未激活，请您首先激活帐号"
			#set_login_session(params[:user]["email"])
			respond_to do |format|
				format.html	{ redirect_to input_activate_email_path and return }
				format.json	{ render :json => ErrorEnum::EMAIL_NOT_ACTIVATED and return }
			end
		when ErrorEnum::WRONG_PASSWORD
			flash[:error] = "密码错误"
			respond_to do |format|
				format.html	{ redirect_to sessions_path and return }
				format.json	{ render :json => ErrorEnum::WRONG_PASSWORD and return }
			end
		else
			tp = User.combine(params[:user]["email"], *third_party_info) if !third_party_info.nil?
			set_login_session(params[:user]["email"])
			flash[:notice] = "登录成功"
			flash[:notice] += "，与第三方帐户绑定失败。" if tp && tp==-41
			flash[:notice] += "，与第三方帐户绑定成功。" if tp && tp!=-41
			respond_to do |format|
				format.html	{ redirect_to home_path and return }
				format.json	{ render :json => true and return }
			end
		end
	end

	#*descryption*: sign out
	#
	#*http* *method*: delete
	#
	#*url*: /sessions
	#
	#*params*:
	#
	#*retval*:
	#* true if successfully logout
	def destroy
		# clear cookie
		set_session(:current_user_email, nil) 
		set_session(:auth_key, nil) 
		# redirect to the welcome page
		respond_to do |format|
			format.html	{ redirect_to root_path and return }
			format.json	{ render :json => true and return }
		end
	end

	# method: get
	# descryption: the page where user inputs the email to reset password
	def forget_password
	end

	#*descryption*: send email to reset password
	#
	#*http* *method*: post
	#
	#*url*: /send_password_email
	#
	#*params*:
	#* email
	#
	#*retval*:
	#* true if successfully send out
	#* ErrorEnum ::EMAIL_NOT_EXIST
	def send_password_email
		if User.user_exist?(params[:email]) == false
			flash[:notice] = "该邮箱未注册，请您注册"
			respond_to do |format|
				format.html { redirect_to registrations_path and return }
				format.json { render :json => ErrorEnum::EMAIL_NOT_EXIST and return }
			end
		end

		user = User.find_by_email(params[:email])
		# send password email
		UserMailer.password_email(user).deliver

		flash[:notice] = "重置密码邮件已发送，请到您的邮箱中点击链接进行密码重置"
		respond_to do |format|
			format.html { redirect_to sessions_path and return }
			format.json { render :json => true and return }
		end
	end

	#*descryption*: user clicks the reset password link
	#
	#*http* *method*: get
	#
	#*url*: /input_new_password
	#
	#*params*:
	#* password_key
	#
	#*retval*:
	#* show the password input form if successfully pass the checking
	#* redirect to forget_password_url if expired
	#* redirect to /500 if it is a wrong link
	def input_new_password
		begin
			password_info_json = Encryption.decrypt_activate_key(params[:password_key])
		rescue
			redirect_to "/500" and return
		end
		redirect_to "/500" and return if password_info_json.nil?
		password_info = JSON.parse(password_info_json)
		if Time.now.to_i - password_info["time"].to_i > OOPSDATA[RailsEnv.get_rails_env]["password_expiration_time"].to_i
			flash[:notice] = "密码重置链接已经过期，请重新发送重置密码链接"
			redirect_to forget_password_url and return
		end
		@email = password_info["email"]
		if User.user_exist?(@email) == false
			redirect_to "/500" and return			# wrong email (link is not generated by our website)
		end
	end

	# method: post
	#*descryption*: user submits the new password
	#
	#*http* *method*: post
	#
	#*url*: /new_password
	#
	#*params*:
	#* user: a hash that has the following keys
	#  - email
	#  - password
	#  - password_confirmation
	#* password_key
	#
	#*retval*:
	#* true if password is reset
	#* ErrorEnum::EMAIL_NOT_EXIST
	def new_password
		begin
			password_info_json = Encryption.decrypt_activate_key(params[:password_key])
		rescue
			respond_to do |format|
				format.html { redirect_to "/500" and return }		# email account does not exist
				format.json { render :json => false and return }		# email account does not exist
			end
		end
		if password_info_json.nil?
			respond_to do |format|
				format.html { redirect_to "/500" and return }		# email account does not exist
				format.json { render :json => false and return }		# email account does not exist
			end
		end
		password_info = JSON.parse(password_info_json)
		if Time.now.to_i - password_info["time"].to_i > OOPSDATA[RailsEnv.get_rails_env]["password_expiration_time"].to_i
			flash[:notice] = "密码重置链接已经过期，请重新发送重置密码链接"
			respond_to do |format|
				format.html { redirect_to forget_password_url and return }		# email account does not exist
				format.json { render :json => ErrorEnum::RESET_PASSWORD_EXPIRED and return }		# email account does not exist
			end
		end
		if password_info["email"] != params[:user]["email"]
			respond_to do |format|
				format.html { redirect_to "/500" and return }		# email account does not exist
				format.json { render :json => ErrorEnum::EMAIL_NOT_EXIST and return }		# email account does not exist
			end
		end

		retval = User.reset_password(params[:user]["email"], params[:user]["password"], params[:user]["password_confirmation"])
		case retval
		when ErrorEnum::EMAIL_NOT_EXIST
			respond_to do |format|
				format.html { redirect_to "/500" and return }		# email account does not exist
				format.json { render :json => ErrorEnum::EMAIL_NOT_EXIST and return }		# email account does not exist
			end
		when ErrorEnum::WRONG_PASSWORD_CONFIRMATION
			respond_to do |format|
				format.html { redirect_to "/500" and return }
				format.json { render :json => ErrorEnum::WRONG_PASSWORD_CONFIRMATION and return }
			end
		else
			flash[:notice] = "密码已重置"
			respond_to do |format|
				format.html { redirect_to sessions_path and return }
				format.json { render :json => true and return }
			end
		end
	end

	#*descryption*: be involved from renren connect
	#
	#*params*:
	#* code
	def renren_connect
		raise "Do not have :code params." if params[:code].nil?
		status, renren_user = RenrenUser.token(params[:code])
		deal_connect(status, renren_user)
	end 

  #*descryption*: be involved from sina connect
	#
	#*params*:
	#* code
	def sina_connect
		raise "Do not have :code params." if params[:code].nil?
		status, sina_user = SinaUser.token(params[:code])
		deal_connect(status, sina_user)
	end 

  #*descryption*: be involved from qq connect
	#
	#*params*:
	#* code
	def qq_connect
	  raise "Do not have :code params." if params[:code].nil?
		status, qq_user = QqUser.token(params[:code])
		deal_connect(status, qq_user)
	end 

  #*descryption*: be involved from google connect
	#
	#*params*:
	#* code
	def google_connect
  	raise "Do not have :code params." if params[:code].nil?
	  status, g_user = GoogleUser.token(params[:code])
	  deal_connect(status, g_user)
	end

  #*descryption*: be involved from qihu connect
	#
	#*params*:
	#* code
  def qihu_connect
    flash[:notice] = "尚未支持奇虎第三方登录。"
    render :action => "index", :controller => "sessions"
    
	  raise "Do not have :code params." if params[:code].nil?
	  status, qihu_user = QihuUser.token(params[:code])
	  deal_connect(status, qihu_user)
  end 
	
	#*descryption*: deal with the third party user login logic
	#
	#*params*:
	#* status
	#* tp_user
	def deal_connect(status, tp_user)
	  case status
	  when ErrorEnum::SAVE_FAILED
	    flash[:error] ="数据保存有误！"
      render :action => "index", :controller => "sessions"
	  when ErrorEnum::THIRD_PARTY_USER_NOT_BIND
	 
	    if user_signed_in? then
	      #if user have login , then combine it.
        User.combine(@current_user.email, tp_user.website, tp_user.user_id)   
        flash[:notice] = "成功将OopsData帐户与第三方帐户绑定。"
        respond_to do |format|
          format.html	{ redirect_to home_path and return }
          format.json	{ render :json => true and return }
        end
      end
      
      # if not login, render page
	    @third_party_info = encrypt_third_party_user_id(tp_user.website, tp_user.user_id)
	    Logger.new("log/development.log").info("#{tp_user.website}: #{tp_user.user_id}") 
      flash[:notice] = "第三方登录成功！请登录OopsData帐户或者注册进行绑定。"
      render :action => "index", :controller => "sessions"
	  when ErrorEnum::EMAIL_NOT_ACTIVATED
      flash[:notice] = "第三方登帐户与OopsData帐户已绑定，但尚未激活。"
      render :action => "index", :controller => "sessions"
	  else 
	    user = User.find_by_email(tp_user.email)
	    if !user_signed_in? then
	      # if user have not login, do login.
        User.login(user.email, Encryption.decrypt_password(user.password), @client_ip)
        set_login_session(user.email)
      end
      flash[:notice] = "登录成功（已绑定）"
      respond_to do |format|
        format.html	{ redirect_to home_path and return }
        format.json	{ render :json => true and return }
      end
	  end
	end

	private

	# method: in-accessible
	# description: help set session for an email account
	def set_login_session(email)
		set_session(:current_user_email, email) 
		auth_key = Encryption.encrypt_auth_key("#{email}&#{Time.now.to_i.to_s}")
		set_session(:auth_key, auth_key)
		User.set_auth_key(email, auth_key)
	end

	def encrypt_third_party_user_id(website, user_id)
		return Encryption.encrypt_third_party_user_id({"website" => website, "user_id" => user_id}.to_json)
	end
end
